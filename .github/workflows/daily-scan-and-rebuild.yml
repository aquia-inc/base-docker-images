# .github/workflows/daily-scan-rebuild.yml
name: Daily Vulnerability Scan and Rebuild

on:
  schedule:
    # Runs daily at 10:00 UTC (5 AM EST / 6 AM EDT)
    - cron: '0 10 * * *'
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  GH_REPO: ${{ github.repository }}
  TRIGGER_SEVERITIES: "CRITICAL,HIGH,MEDIUM"

jobs:
  scan_and_rebuild:
    runs-on: ubuntu-latest
    permissions:
      contents: write    # Needed to push new tags
      packages: read     # Needed to pull images and inspect manifests
      actions: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0 # Required to list tags

      - name: Discover available base images
        id: discover_images
        run: |
          BASE_NAMES=$(find . -maxdepth 1 -name 'Dockerfile.*' -type f -printf '%f\n' | sed 's/^Dockerfile\.//' | sort -u | paste -sd ' ')
          if [ -z "$BASE_NAMES" ]; then
            echo "::error::No Dockerfiles found matching 'Dockerfile.*'"
            exit 1
          fi
          echo "Discovered image base names: $BASE_NAMES"
          echo "IMAGE_BASE_NAMES=$BASE_NAMES" >> $GITHUB_ENV

      - name: Setup Docker environment
        uses: ./.github/actions/setup-docker
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Trivy scanner
        run: |
          # Install Trivy for vulnerability scanning
          sudo apt-get update
          sudo apt-get install -y wget apt-transport-https gnupg lsb-release jq
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | gpg --dearmor | sudo tee /usr/share/keyrings/trivy.gpg > /dev/null
          echo "deb [signed-by=/usr/share/keyrings/trivy.gpg] https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee /etc/apt/sources.list.d/trivy.list > /dev/null
          sudo apt-get update
          sudo apt-get install -y trivy

      - name: Scan images and determine rebuild requirements
        id: scan_check_rebuild
        run: |
          set -e # Exit on most errors, but parsing/scan failures handled below

          needs_rebuild_list=""

          if [ -z "$IMAGE_BASE_NAMES" ]; then
              echo "::error::IMAGE_BASE_NAMES environment variable is not set. Discovery might have failed."
              exit 1
          fi
          echo "Processing image base names: $IMAGE_BASE_NAMES"

          for base_name in $IMAGE_BASE_NAMES; do
            echo "=== Processing image base name: $base_name ==="
            found_fixable_vulns_for_base=false
            rebuild_reason=""

            for platform_suffix in linux-amd64 linux-arm64; do
              image_name="${base_name}-${platform_suffix}"
              full_image_tag="${{ env.REGISTRY }}/${{ env.GH_REPO }}/${image_name}:latest"

              echo "Checking image: $full_image_tag"

              # Check if image exists before scanning
              if ! docker manifest inspect "$full_image_tag" > /dev/null 2>&1; then
                echo "::warning::Image $full_image_tag not found in registry. Skipping scan for this platform."
                continue # Skip to next platform
              fi

              echo "Scanning $full_image_tag for vulnerabilities (severities: ${{ env.TRIGGER_SEVERITIES }})"
              # Run Trivy vulnerability scan
              if trivy image \
                --ignore-unfixed \
                --exit-code 1 \
                --severity ${{ env.TRIGGER_SEVERITIES }} \
                --format table \
                "$full_image_tag"; then
                echo "âœ… No fixable vulnerabilities found in $full_image_tag"
              else
                scan_exit_code=$?
                if [ $scan_exit_code -eq 1 ]; then
                  echo "âš ï¸  Fixable vulnerabilities found in $full_image_tag"
                  found_fixable_vulns_for_base=true
                else
                  echo "âŒ Trivy scan failed for $full_image_tag (exit code: $scan_exit_code)"
                  # Continue processing other platforms
                fi
              fi
            done # End platform loop

            # Check if we need to rebuild based on vulnerabilities + base image freshness
            if [ "$found_fixable_vulns_for_base" = true ]; then
              echo "ðŸ” Vulnerabilities found for $base_name. Checking base image freshness..."
              dockerfile="Dockerfile.$base_name"
              if [ ! -f "$dockerfile" ]; then
                echo "::error::Dockerfile $dockerfile not found. Cannot check base image. Skipping rebuild trigger for $base_name."
                continue # Skip to next base_name
              fi

              # Extract base image information from Dockerfile
              from_line=$(grep -i '^FROM' "$dockerfile" | head -n 1)
              echo "Parsing FROM line: $from_line"

              # Extract image name and SHA from FROM line
              from_image_name=$(echo "$from_line" | sed -E -n 's/^FROM\s+([^@]+)@sha256:.*/\1/p')
              current_sha_with_prefix=$(echo "$from_line" | sed -E -n 's/.*(@sha256:[a-f0-9]{64}).*/\1/p')

              # Trim whitespace
              from_image_name=$(echo "$from_image_name" | xargs)

              if [ -n "$from_image_name" ] && [ -n "$current_sha_with_prefix" ]; then
                current_sha_digest="${current_sha_with_prefix#@}" # Remove the '@' prefix
                echo "Dockerfile uses base image: [$from_image_name] with SHA: [$current_sha_digest]"

                echo "Querying registry for latest digest of [$from_image_name]..."
                if latest_sha_digest=$(docker manifest inspect "$from_image_name" | jq -r 'if type == "array" then .[0].digest else (.manifests[0].digest // .config.digest // .digest) end // empty'); then
                  if [ -n "$latest_sha_digest" ]; then
                    echo "Latest digest found: [$latest_sha_digest]"
                    if [ "$current_sha_digest" != "$latest_sha_digest" ]; then
                      echo "ðŸ”„ Base image has updates: $latest_sha_digest vs $current_sha_digest"
                      echo "Adding '$base_name' to rebuild list (vulnerabilities found + outdated base image)"
                      needs_rebuild_list="${needs_rebuild_list} ${base_name}"
                      rebuild_reason="Fixable vulnerabilities found and base image $from_image_name has updates."
                    else
                      echo "âœ… Base image [$from_image_name] is up-to-date. Skipping rebuild despite vulnerabilities."
                      rebuild_reason="Fixable vulnerabilities found, but base image $from_image_name is already up-to-date."
                    fi
                  else
                    echo "::warning::Could not extract latest digest from manifest for [$from_image_name]. Skipping rebuild."
                    rebuild_reason="Fixable vulnerabilities found, but could not determine latest base image digest."
                  fi
                else
                  echo "::warning::Failed to inspect manifest for base image [$from_image_name]. Skipping rebuild."
                  rebuild_reason="Fixable vulnerabilities found, but failed to inspect base image $from_image_name."
                fi
              else
                echo "::error::Could not parse FROM line components in $dockerfile. Line was: '$from_line'"
                rebuild_reason="Fixable vulnerabilities found, but could not parse FROM line in $dockerfile."
              fi
            else
              echo "âœ… No fixable vulnerabilities found for $base_name"
              rebuild_reason="No fixable vulnerabilities found."
            fi
            echo "Decision for $base_name: $rebuild_reason"
          done # End base_name loop

          # Process rebuild list
          unique_needs_rebuild=$(echo "$needs_rebuild_list" | xargs -n1 | sort -u | xargs)

          if [ -z "$unique_needs_rebuild" ]; then
            echo "âœ… No images require rebuilding based on vulnerability scans and base image freshness checks."
            echo "triggered_rebuilds=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "ðŸš€ Triggering rebuilds for: $unique_needs_rebuild"
          echo "triggered_rebuilds=true" >> $GITHUB_OUTPUT
          echo "rebuild_list=$unique_needs_rebuild" >> $GITHUB_OUTPUT

          # Configure git for creating tags
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          for base_name in $unique_needs_rebuild; do
            echo "Creating rebuild tag for $base_name..."

            # Find latest release tag
            latest_release_tag=$(git tag --list "release/${base_name}/v*" | sort -V | tail -n 1)

            if [ -z "$latest_release_tag" ]; then
              echo "::error::Could not find any release tag matching 'release/${base_name}/v*' to base the rebuild on. Skipping rebuild trigger for $base_name."
              continue
            fi
            echo "Latest release tag found: $latest_release_tag"

            # Extract version and create rebuild tag
            version_part=$(echo "$latest_release_tag" | sed -n "s|release/${base_name}/\(v.*\)|\1|p")
            if [ -z "$version_part" ]; then
              echo "::error::Could not extract version part from tag '$latest_release_tag'. Skipping rebuild for $base_name."
              continue
            fi

            # Increment patch version for clean semver
            version_part_clean=$(echo "$version_part" | sed 's/\+.*//')
            # Extract current version numbers (e.g., v1.2.3 -> 1 2 3)
            version_nums=$(echo "$version_part_clean" | sed 's/^v//' | tr '.' ' ')
            major=$(echo $version_nums | cut -d' ' -f1)
            minor=$(echo $version_nums | cut -d' ' -f2)
            patch=$(echo $version_nums | cut -d' ' -f3)
            
            # Increment patch version
            new_patch=$((patch + 1))
            new_version="v${major}.${minor}.${new_patch}"
            new_tag="release/${base_name}/${new_version}"

            echo "Creating and pushing rebuild tag: $new_tag"
            git tag "$new_tag"
            git push origin "$new_tag"
            echo "âœ… Rebuild triggered for $base_name by pushing tag $new_tag"
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
