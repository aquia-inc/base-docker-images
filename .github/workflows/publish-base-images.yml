# .github/workflows/publish-base-images.yml
name: Publish Base Docker images

on:
  push:
    tags:
      - "release/**"
    branches:
      - main
  pull_request:
    branches: [main]

env:
  REGISTRY: ghcr.io
  # For tag pushes, use the actual ref. For PRs, detect from modified Dockerfiles
  TAG: ${{ github.ref }}

jobs:
  publish_image:
    runs-on: ubuntu-latest
    env:  # Add GH_TOKEN at the job level
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    strategy:
      fail-fast: false
      matrix:
        platform: [linux/amd64, linux/arm64]
    permissions:
      contents: write
      packages: write
      security-events: write
      actions: read
      attestations: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0  # Need full history for git diff comparisons

      - name: Detect image for PR builds
        id: detect_image
        if: github.event_name == 'pull_request'
        run: |
          modified_dockerfile=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | grep "^Dockerfile\." | head -n 1)
          if [ -n "$modified_dockerfile" ]; then
            detected_image=$(echo "$modified_dockerfile" | sed 's/^Dockerfile\.//')
            detected_tag="release/${detected_image}/v0.0.0-pr"
            echo "TAG=$detected_tag" >> $GITHUB_ENV
            echo "dockerfile_found=true" >> $GITHUB_OUTPUT
            echo "Detected image from PR: $detected_image, using tag: $detected_tag"
          else
            echo "dockerfile_found=false" >> $GITHUB_OUTPUT
            echo "No Dockerfile changes detected in PR, will exit early"
          fi

      - name: Exit early if no Dockerfile changes in PR
        if: github.event_name == 'pull_request' && steps.detect_image.outputs.dockerfile_found != 'true'
        run: |
          echo "No Dockerfile changes detected in PR, exiting."
          exit 0

      - name: Parse image context
        id: context
        uses: ./.github/actions/parse-image-context
        with:
          tag: ${{ env.TAG }}
          platform: ${{ matrix.platform }}

      - name: Check if Dockerfile changed for this image
        id: dockerfile_check
        run: |
          # For non-tag pushes, always proceed
          if [[ "${{ github.event_name }}" != "push" || "${{ github.ref_type }}" != "tag" ]]; then
            echo "dockerfile_changed=true" >> $GITHUB_OUTPUT
            echo "Not a tag push, proceeding with build"
            exit 0
          fi

          dockerfile_path="Dockerfile.${{ steps.context.outputs.image-base-name }}"
          echo "Checking if $dockerfile_path was modified..."
          # Get the previous tag for this image
          prev_tag=$(git tag -l "release/${{ steps.context.outputs.image-base-name }}/v*" --sort=-version:refname | head -n 2 | tail -n 1)
          if [ -n "$prev_tag" ]; then
            echo "Comparing with previous tag: $prev_tag"
            if git diff --name-only "$prev_tag" HEAD | grep -q "^${dockerfile_path}$"; then
              echo "dockerfile_changed=true" >> $GITHUB_OUTPUT
              echo "Dockerfile $dockerfile_path was modified since $prev_tag"
            else
              echo "dockerfile_changed=false" >> $GITHUB_OUTPUT
              echo "Dockerfile $dockerfile_path was NOT modified since $prev_tag - skipping build"
            fi
          else
            echo "dockerfile_changed=true" >> $GITHUB_OUTPUT
            echo "No previous tag found, assuming Dockerfile changed"
          fi

      - name: Exit early if Dockerfile unchanged
        if: steps.dockerfile_check.outputs.dockerfile_changed != 'true'
        run: |
          echo "Did not detect any modified Dockerfiles in this commit, exiting."
          exit 0

      - name: Setup Docker environment
        uses: ./.github/actions/setup-docker
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          platform: ${{ matrix.platform }}

      - name: Build Docker Image for ${{ matrix.platform }} (Test)
        id: build_test
        uses: docker/build-push-action@v6
        with:
          pull: true
          file: Dockerfile.${{ steps.context.outputs.image-base-name }}
          platforms: ${{ matrix.platform }}
          load: true
          tags: ${{ github.repository }}/${{ steps.context.outputs.image-name }}:test
          cache-from: type=gha,scope=${{ github.repository }}-${{ steps.context.outputs.image-name }}
          cache-to: type=gha,mode=max,scope=${{ github.repository }}-${{ steps.context.outputs.image-name }}

      - name: Output Docker Image Size for ${{ matrix.platform }}
        run: |
          image_tag="${{ github.repository }}/${{ steps.context.outputs.image-name }}:test"
          echo "Getting size for image: $image_tag"
          size=$(docker images --format "table {{.Size}}" "$image_tag" | tail -n +2)
          echo "Docker image size for ${{ matrix.platform }}: $size"

      - name: Run container structure tests
        run: |
          curl -LO https://storage.googleapis.com/container-structure-test/latest/container-structure-test-linux-amd64
          chmod +x container-structure-test-linux-amd64
          sudo mv container-structure-test-linux-amd64 /usr/local/bin/container-structure-test

      - name: Run Container Structure Tests for ${{ matrix.platform }}
        run: |
          image_base_name="${{ steps.context.outputs.image-base-name }}"
          test_config="tests/container-structure/${image_base_name}.yaml"
          image_tag="${{ github.repository }}/${{ steps.context.outputs.image-name }}:test"
          
          # Run tests if config exists
          test_config="tests/container-structure/${{ steps.context.outputs.image-base-name }}.yaml"
          if [ -f "$test_config" ]; then
            echo "Running container structure tests with config: $test_config"
            container-structure-test test \
              --image "${{ github.repository }}/${{ steps.context.outputs.image-name }}:test" \
              --config "$test_config"
          else
            echo "No container structure test config found at $test_config, skipping tests"
          fi

      - name: Run Trivy vulnerability scanner for ${{ matrix.platform }}
        uses: aquasecurity/trivy-action@77137e9dc3ab1b329b7c8a38c2eb7475850a14e8
        with:
          scan-type: image
          image-ref: ${{ github.repository }}/${{ steps.context.outputs.image-name }}:test
          format: table
          exit-code: "1"
          ignore-unfixed: true
          vuln-type: "os,library"
          severity: "CRITICAL,HIGH,MEDIUM"

      - name: Get installed package versions for ${{ matrix.platform }}
        id: get_versions
        run: |
          # Download container-structure-test if not available
          if ! command -v container-structure-test &> /dev/null; then
            echo "Downloading container-structure-test..."
            curl -LO https://storage.googleapis.com/container-structure-test/latest/container-structure-test-linux-amd64
            chmod +x container-structure-test-linux-amd64
            sudo mv container-structure-test-linux-amd64 /usr/local/bin/container-structure-test
          fi
          
          # Run tests if config exists
          test_config="tests/container-structure/${{ steps.context.outputs.image-base-name }}.yaml"
          if [ -f "$test_config" ]; then
            echo "Running container structure tests with config: $test_config"
            container-structure-test test \
              --image "${{ github.repository }}/${{ steps.context.outputs.image-name }}:test" \
              --config "$test_config"
          else
            echo "No container structure test config found at $test_config, skipping tests"
          fi

      - name: Run Trivy vulnerability scanner for ${{ matrix.platform }}
        uses: aquasecurity/trivy-action@77137e9dc3ab1b329b7c8a38c2eb7475850a14e8
        with:
          scan-type: image
          image-ref: ${{ github.repository }}/${{ steps.context.outputs.image-name }}:test
          format: table
          exit-code: "1"
          ignore-unfixed: true
          vuln-type: "os,library"
          severity: "CRITICAL,HIGH,MEDIUM"

      - name: Extract language versions
        id: extract_versions
        uses: ./.github/actions/extract-versions
        with:
          image-base-name: ${{ steps.context.outputs.image-base-name }}
          image-tag: ${{ github.repository }}/${{ steps.context.outputs.image-name }}:test
          platform: ${{ matrix.platform }}
          platform-suffix: ${{ steps.context.outputs.platform-suffix }}

      - name: Upload versions artifact for ${{ matrix.platform }}
        uses: actions/upload-artifact@v4
        if: steps.extract_versions.outputs.extraction-success == 'true' && github.event_name == 'push' && github.ref_type == 'tag'
        with:
          name: versions-file-${{ steps.context.outputs.platform-suffix }}
          path: ${{ steps.extract_versions.outputs.versions-file }}
          retention-days: 1
          if-no-files-found: error

      - name: Calculate version tags for all image types
        id: version_tags
        run: |
          image_name="${{ steps.context.outputs.image-base-name }}"
          
          echo "Processing image: $image_name"
          
          # Initialize outputs
          echo "has_version_tags=false" >> $GITHUB_OUTPUT
          echo "major_tag=" >> $GITHUB_OUTPUT
          echo "minor_tag=" >> $GITHUB_OUTPUT
          echo "tool_version=" >> $GITHUB_OUTPUT
          
          case "$image_name" in
            # Language images - extract runtime versions from /tmp/versions.txt
            "python-base"|"nodejs-base"|"openjdk17-base"|"go-base")
              echo "Language image detected, extracting runtime versions..."
              
              if docker run --rm --platform ${{ matrix.platform }} \
                 "${{ github.repository }}/${{ steps.context.outputs.image-name }}:test" \
                 sh -c 'cat /tmp/versions.txt' > versions.txt 2>/dev/null; then
                
                echo "Successfully extracted versions.txt:"
                cat versions.txt
                
                # Parse based on image type
                case "$image_name" in
                  "python-base")
                    MAJOR_TAG=$(grep "python_major_tag=" versions.txt | cut -d'=' -f2)
                    MINOR_TAG=$(grep "python_minor_tag=" versions.txt | cut -d'=' -f2)
                    ;;
                  "nodejs-base")
                    MAJOR_TAG=$(grep "nodejs_major_tag=" versions.txt | cut -d'=' -f2)
                    MINOR_TAG=$(grep "nodejs_minor_tag=" versions.txt | cut -d'=' -f2)
                    ;;
                  "openjdk17-base")
                    MAJOR_TAG=$(grep "java_major_tag=" versions.txt | cut -d'=' -f2)
                    MINOR_TAG=$(grep "java_minor_tag=" versions.txt | cut -d'=' -f2)
                    ;;
                  "go-base")
                    MAJOR_TAG=$(grep "go_major_tag=" versions.txt | cut -d'=' -f2)
                    MINOR_TAG=$(grep "go_minor_tag=" versions.txt | cut -d'=' -f2)
                    ;;
                esac
                
                if [ -n "$MAJOR_TAG" ] && [ -n "$MINOR_TAG" ]; then
                  echo "major_tag=$MAJOR_TAG" >> $GITHUB_OUTPUT
                  echo "minor_tag=$MINOR_TAG" >> $GITHUB_OUTPUT
                  echo "has_version_tags=true" >> $GITHUB_OUTPUT
                  echo "✅ Runtime version tags: major=$MAJOR_TAG, minor=$MINOR_TAG"
                fi
                rm -f versions.txt
              else
                echo "⚠️  Failed to extract versions.txt from container"
              fi
              ;;
              
            # Specialized tool images - extract tool versions directly
            "fips-base")
              echo "FIPS image detected, extracting OpenSSL version..."
              
              if OPENSSL_VERSION=$(docker run --rm --platform ${{ matrix.platform }} \
                 "${{ github.repository }}/${{ steps.context.outputs.image-name }}:test" \
                 /usr/local/ssl/bin/openssl version 2>/dev/null | awk '{print $2}'); then
                
                echo "OpenSSL version: $OPENSSL_VERSION"
                
                # Extract major.minor (e.g., 3.0.9 -> 3.0)
                OPENSSL_MAJOR=$(echo "$OPENSSL_VERSION" | cut -d'.' -f1)
                OPENSSL_MINOR=$(echo "$OPENSSL_VERSION" | cut -d'.' -f1-2)
                
                if [ -n "$OPENSSL_MAJOR" ] && [ -n "$OPENSSL_MINOR" ]; then
                  echo "major_tag=openssl$OPENSSL_MAJOR" >> $GITHUB_OUTPUT
                  echo "minor_tag=openssl$OPENSSL_MINOR" >> $GITHUB_OUTPUT
                  echo "tool_version=$OPENSSL_VERSION" >> $GITHUB_OUTPUT
                  echo "has_version_tags=true" >> $GITHUB_OUTPUT
                  echo "✅ OpenSSL version tags: major=openssl$OPENSSL_MAJOR, minor=openssl$OPENSSL_MINOR"
                fi
              else
                echo "⚠️  Failed to extract OpenSSL version"
              fi
              ;;
              
            "nginx-base")
              echo "Nginx image detected, extracting Nginx version..."
              
              # Extract nginx version using direct binary call
              if NGINX_VERSION=$(docker run --rm --platform ${{ matrix.platform }} \
                 --entrypoint="/usr/sbin/nginx" \
                 "${{ github.repository }}/${{ steps.context.outputs.image-name }}:test" \
                 -v 2>&1 | grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+' | head -1); then
                
                echo "Nginx version: $NGINX_VERSION"
                
                # Extract major.minor (e.g., 1.29.1 -> 1.29)
                NGINX_MAJOR=$(echo "$NGINX_VERSION" | cut -d'.' -f1)
                NGINX_MINOR=$(echo "$NGINX_VERSION" | cut -d'.' -f1-2)
                
                if [ -n "$NGINX_MAJOR" ] && [ -n "$NGINX_MINOR" ]; then
                  echo "major_tag=nginx$NGINX_MAJOR" >> $GITHUB_OUTPUT
                  echo "minor_tag=nginx$NGINX_MINOR" >> $GITHUB_OUTPUT
                  echo "tool_version=$NGINX_VERSION" >> $GITHUB_OUTPUT
                  echo "has_version_tags=true" >> $GITHUB_OUTPUT
                  echo "✅ Nginx version tags: major=nginx$NGINX_MAJOR, minor=nginx$NGINX_MINOR"
                fi
              else
                echo "⚠️  Failed to extract Nginx version"
              fi
              ;;
              
            # Base images - no version tags needed
            *)
              echo "Base image ($image_name) - no version tags needed"
              ;;
          esac

      - name: Create version tags artifact
        if: github.event_name == 'push' && github.ref_type == 'tag' && steps.version_tags.outputs.has_version_tags == 'true'
        run: |
          mkdir -p version_artifacts
          echo "major_tag=${{ steps.version_tags.outputs.major_tag }}" > version_artifacts/version_tags.env
          echo "minor_tag=${{ steps.version_tags.outputs.minor_tag }}" >> version_artifacts/version_tags.env
          echo "has_version_tags=${{ steps.version_tags.outputs.has_version_tags }}" >> version_artifacts/version_tags.env

      - name: Upload version tags as artifact
        uses: actions/upload-artifact@v4
        if: github.event_name == 'push' && github.ref_type == 'tag' && steps.version_tags.outputs.has_version_tags == 'true'
        with:
          name: version-tags-${{ steps.context.outputs.image-base-name }}-${{ steps.context.outputs.platform-suffix }}
          path: version_artifacts/version_tags.env
          retention-days: 1
          if-no-files-found: warn

      - name: Generate build timestamp
        id: build_timestamp
        run: echo "created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_OUTPUT

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5.8.0
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository }}/${{ steps.context.outputs.image-name }}
          tags: |
            # Standard tags: version, latest, dev-<sha>
            type=raw,value=${{ steps.context.outputs.version }},enable=${{ github.event_name == 'push' && github.ref_type == 'tag' }}
            type=raw,value=latest,enable=${{ github.event_name == 'push' && github.ref_type == 'tag' }}
            type=raw,value=dev-${{ github.sha }},enable=${{ github.event_name != 'push' || github.ref_type != 'tag' }}

            # Universal version tags for all image types
            type=raw,value=${{ steps.version_tags.outputs.major_tag }},enable=${{ steps.version_tags.outputs.has_version_tags == 'true' && github.event_name == 'push' && github.ref_type == 'tag' }}
            type=raw,value=${{ steps.version_tags.outputs.minor_tag }},enable=${{ steps.version_tags.outputs.has_version_tags == 'true' && github.event_name == 'push' && github.ref_type == 'tag' }}
          labels: |
            # See https://github.com/opencontainers/image-spec/blob/main/annotations.md
            org.opencontainers.image.title=${{ steps.context.outputs.image-name }} (${{ matrix.platform }})
            org.opencontainers.image.description=Base image for ${{ steps.context.outputs.image-base-name }} targeting ${{ matrix.platform }}
            org.opencontainers.image.url=https://github.com/${{ github.repository }}
            org.opencontainers.image.source=https://github.com/${{ github.repository }}.git
            org.opencontainers.image.version=${{ steps.context.outputs.version }}
            org.opencontainers.image.created=${{ steps.build_timestamp.outputs.created }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.vendor=Aquia Inc
            org.opencontainers.image.platform=${{ matrix.platform }}
            # Custom annotations
            build-url=${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
            # --- Add language version labels if available ---
            # Python
            python.version.major=${{ env.python_major_tag }}
            python.version.minor=${{ env.python_minor_tag }}
            python.version.full=${{ env.python }}
            # Node.js
            nodejs.version.major=${{ env.nodejs_major_tag }}
            nodejs.version.minor=${{ env.nodejs_minor_tag }}
            nodejs.version.full=${{ env.nodejs }}
            # Java (OpenJDK)
            java.version.major=${{ env.java_major_tag }}
            java.version.minor=${{ env.java_minor_tag }}
            java.version.full=${{ env.java }}
            # Go
            go.version.major=${{ env.go_major_tag }}
            go.version.minor=${{ env.go_minor_tag }}
            go.version.full=${{ env.go }}
            org.opencontainers.image.architecture=${{ matrix.platform }}

      - name: Auto-fix nginx compatibility (nginx-base only)
        if: steps.parse_tag.outputs.image_base_name == 'nginx-base'
        id: nginx-autofix
        run: |
          # Get versions (fixed grep for cross-platform compatibility)
          CHAINGUARD_VERSION=$(docker run --rm --entrypoint="" cgr.dev/chainguard/nginx:latest nginx -v 2>&1 | grep -o 'nginx/[0-9][0-9.]*' | cut -d'/' -f2)
          DOCKERFILE_VERSION=$(grep 'ARG NGINX_VERSION=' Dockerfile.nginx-base | cut -d'=' -f2)
          CURRENT_HEADERS=$(grep 'ARG MORE_HEADERS_VERSION=' Dockerfile.nginx-base | cut -d'=' -f2)
          
          echo "Chainguard nginx: $CHAINGUARD_VERSION"
          echo "Dockerfile nginx: $DOCKERFILE_VERSION" 
          echo "Current headers-more: v$CURRENT_HEADERS"
          
          if [ "$CHAINGUARD_VERSION" != "$DOCKERFILE_VERSION" ]; then
            echo "🔄 Nginx version mismatch detected - applying auto-fix"
            
            # Bump headers-more version by 0.01 (fixed calculation)
            NEW_HEADERS=$(echo "$CURRENT_HEADERS + 0.01" | bc -l | awk '{printf "%.2f", $0}' | sed 's/\.00$//')
            
            echo "Auto-updating versions:"
            echo "  nginx: $DOCKERFILE_VERSION → $CHAINGUARD_VERSION"
            echo "  headers-more: v$CURRENT_HEADERS → v$NEW_HEADERS"
            
            # Backup original Dockerfile
            cp Dockerfile.nginx-base Dockerfile.nginx-base.backup
            
            # Update Dockerfile
            sed -i "s/ARG NGINX_VERSION=.*/ARG NGINX_VERSION=$CHAINGUARD_VERSION/" Dockerfile.nginx-base
            sed -i "s/ARG MORE_HEADERS_VERSION=.*/ARG MORE_HEADERS_VERSION=$NEW_HEADERS/" Dockerfile.nginx-base
            
            # Test the build with --pull flag (with timeout for CI)
            echo "Testing updated configuration..."
            BUILD_SUCCESS=false
            
            # Use timeout if available (Linux CI), otherwise rely on GitHub Actions timeout
            if command -v timeout >/dev/null 2>&1; then
              TIMEOUT_CMD="timeout 300"
            else
              TIMEOUT_CMD=""
            fi
            
            if $TIMEOUT_CMD docker build --pull -q -t test-nginx-updated -f Dockerfile.nginx-base . 2>build-error.log; then
              echo "✅ Build phase successful"
              
              # Test module loading
              if docker run --rm --entrypoint="" test-nginx-updated nginx -t 2>module-error.log; then
                echo "✅ Module loading successful"
                BUILD_SUCCESS=true
              else
                echo "❌ Module loading failed"
                cat module-error.log
              fi
            else
              echo "❌ Build phase failed"
              cat build-error.log
            fi
            
            if [ "$BUILD_SUCCESS" = "true" ]; then
              echo "✅ Auto-fix successful - committing changes"
              
              # Commit the change
              git config user.name "github-actions[bot]"
              git config user.email "github-actions[bot]@users.noreply.github.com"
              git add Dockerfile.nginx-base
              git commit -m "Auto-fix: Update nginx to $CHAINGUARD_VERSION with headers-more v$NEW_HEADERS

          🤖 Automated compatibility fix
          - nginx: $DOCKERFILE_VERSION → $CHAINGUARD_VERSION  
          - headers-more: v$CURRENT_HEADERS → v$NEW_HEADERS

          Build and module loading tested successfully with --pull flag."
              
              echo "auto_fix_applied=true" >> $GITHUB_OUTPUT
              echo "fix_successful=true" >> $GITHUB_OUTPUT
              
              # Clean up
              rm -f Dockerfile.nginx-base.backup build-error.log module-error.log
              docker rmi -f test-nginx-updated 2>/dev/null || true
              
            else
              echo "❌ Auto-fix failed - restoring original Dockerfile"
              mv Dockerfile.nginx-base.backup Dockerfile.nginx-base
              
              echo "fix_successful=false" >> $GITHUB_OUTPUT
              echo "auto_fix_applied=true" >> $GITHUB_OUTPUT
              echo "chainguard_version=$CHAINGUARD_VERSION" >> $GITHUB_OUTPUT
              echo "dockerfile_version=$DOCKERFILE_VERSION" >> $GITHUB_OUTPUT
              echo "current_headers=$CURRENT_HEADERS" >> $GITHUB_OUTPUT
              echo "attempted_headers=$NEW_HEADERS" >> $GITHUB_OUTPUT
            fi
          else
            echo "✅ Nginx versions match - no fix needed"
            echo "auto_fix_applied=false" >> $GITHUB_OUTPUT
          fi

      - name: Create issue for failed auto-fix (nginx-base only)
        if: steps.parse_tag.outputs.image_base_name == 'nginx-base' && steps.nginx-autofix.outputs.auto_fix_applied == 'true' && steps.nginx-autofix.outputs.fix_successful == 'false'
        run: |
          echo "🚨 Creating GitHub issue for failed auto-fix"
          
          # Collect error information
          BUILD_ERRORS=""
          MODULE_ERRORS=""
          
          if [ -f build-error.log ]; then
            BUILD_ERRORS=$(cat build-error.log)
          fi
          
          if [ -f module-error.log ]; then
            MODULE_ERRORS=$(cat module-error.log)
          fi
          
          # Create detailed issue
          gh issue create \
            --title "🚨 Nginx auto-fix failed: nginx ${{ steps.nginx-autofix.outputs.chainguard_version }} + headers-more v${{ steps.nginx-autofix.outputs.attempted_headers }}" \
            --body "## Auto-fix Failure Summary

          **The automated nginx compatibility fix has failed and requires manual intervention.**

          ### Version Details
          - **Chainguard nginx version**: ${{ steps.nginx-autofix.outputs.chainguard_version }}
          - **Our dockerfile version**: ${{ steps.nginx-autofix.outputs.dockerfile_version }}
          - **Current headers-more**: v${{ steps.nginx-autofix.outputs.current_headers }}
          - **Attempted headers-more**: v${{ steps.nginx-autofix.outputs.attempted_headers }}

          ### What Failed
          The automatic +0.01 version bump strategy failed during the nginx-base build process (tested with \`--pull\` flag).

          ### Build Errors
          \`\`\`
          $BUILD_ERRORS
          \`\`\`

          ### Module Loading Errors  
          \`\`\`
          $MODULE_ERRORS
          \`\`\`

          ### Manual Action Required
          1. **Check compatibility matrix**: Visit [headers-more compatibility docs](https://github.com/openresty/headers-more-nginx-module#compatibility)
          2. **Research available versions**: Check [available tags](https://github.com/openresty/headers-more-nginx-module/tags)
          3. **Test manually with --pull**: 
             \`\`\`bash
             docker build --pull -t test-nginx -f Dockerfile.nginx-base .
             docker run --rm --entrypoint=\"\" test-nginx nginx -t
             \`\`\`
          4. **Update Dockerfile**: Modify \`Dockerfile.nginx-base\` with working combination
          5. **Consider alternatives**: If no compatible version exists, research alternative nginx modules

          ### Workflow Information
          - **Workflow**: ${{ github.workflow }}
          - **Run ID**: ${{ github.run_id }}
          - **Commit**: ${{ github.sha }}
          - **Triggered by**: ${{ github.event_name }}

          ### Next Steps
          - [ ] Research compatible headers-more version for nginx ${{ steps.nginx-autofix.outputs.chainguard_version }}
          - [ ] Test proposed combination locally with \`--pull\` flag
          - [ ] Update Dockerfile.nginx-base with working versions
          - [ ] Consider improving auto-fix strategy if this becomes frequent

          **This issue was automatically created by the nginx compatibility workflow.**" \
            --label "bug,nginx,auto-fix-failed,needs-manual-intervention" \
            --assignee "${{ github.actor }}"

      - name: Fail build on auto-fix failure (nginx-base only)
        if: steps.parse_tag.outputs.image_base_name == 'nginx-base' && steps.nginx-autofix.outputs.auto_fix_applied == 'true' && steps.nginx-autofix.outputs.fix_successful == 'false'
        run: |
          echo "💥 BUILD FAILURE: Nginx auto-fix unsuccessful"
          echo ""
          echo "The nginx-base image cannot be built with the current configuration."
          echo "A GitHub issue has been created for manual resolution."
          echo ""
          echo "Build will not proceed to prevent publishing a broken image."
          
          # Clean up temporary files
          rm -f build-error.log module-error.log
          
          exit 1

      - name: Build and push Docker image for ${{ matrix.platform }}
        id: docker_build
        uses: docker/build-push-action@v6
        if: github.event_name == 'push' && github.ref_type == 'tag'
        with:
          pull: true
          file: Dockerfile.${{ steps.context.outputs.image-base-name }}
          push: true
          platforms: ${{ matrix.platform }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=${{ github.repository }}-${{ steps.context.outputs.image-name }}
          cache-to: type=gha,mode=max,scope=${{ github.repository }}-${{ steps.context.outputs.image-name }}

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3
        if: github.event_name == 'push' && github.ref_type == 'tag'
        
      - name: Sign container image with Cosign
        id: cosign_sign
        if: github.event_name == 'push' && github.ref_type == 'tag' && steps.docker_build.outputs.digest != ''
        env:
          COSIGN_EXPERIMENTAL: 1
        run: |
          # Sign the image with keyless signing (uses OIDC)
          echo "Signing image: ${{ env.REGISTRY }}/${{ github.repository }}/${{ steps.context.outputs.image-name }}@${{ steps.docker_build.outputs.digest }}"
          cosign sign --yes \
            ${{ env.REGISTRY }}/${{ github.repository }}/${{ steps.context.outputs.image-name }}@${{ steps.docker_build.outputs.digest }}
          
          # Get the Rekor log entry
          REKOR_UUID=$(cosign verify \
            --certificate-identity-regexp "https://github.com/${{ github.repository }}/.github/workflows/.*" \
            --certificate-oidc-issuer "https://token.actions.githubusercontent.com" \
            ${{ env.REGISTRY }}/${{ github.repository }}/${{ steps.context.outputs.image-name }}@${{ steps.docker_build.outputs.digest }} 2>&1 | \
            grep -oP 'Rekor: \K[0-9a-f]{64}' | head -n1)
          
          if [ -n "$REKOR_UUID" ]; then
            echo "rekor_uuid=$REKOR_UUID" >> $GITHUB_OUTPUT
            echo "Rekor UUID: $REKOR_UUID"
          fi
          
      - name: Attest build provenance for ${{ matrix.platform }}
        id: attest_provenance
        uses: actions/attest-build-provenance@e8998f949152b193b063cb0ec769d69d929409be # v2.4.0
        if: github.event_name == 'push' && github.ref_type == 'tag' && steps.docker_build.outputs.digest != ''
        with:
          # Create cryptographic attestation for build provenance
          subject-name: ${{ env.REGISTRY }}/${{ github.repository }}/${{ steps.context.outputs.image-name }}
          subject-digest: ${{ steps.docker_build.outputs.digest }}
          push-to-registry: true

      - name: Extract Sigstore logIndex for ${{ matrix.platform }}
        id: extract_logindex
        if: github.event_name == 'push' && github.ref_type == 'tag'
        run: |
          echo "Attestation URL: ${{ steps.attest_provenance.outputs.attestation-url }}"
          echo "Bundle path: ${{ steps.attest_provenance.outputs.bundle-path }}"
          
          # Save provenance information to file
          output_file="env.provenance.${{ steps.context.outputs.platform-suffix }}"
          
          # Extract logIndex from the attestation bundle
          if [ -n "${{ steps.attest_provenance.outputs.bundle-path }}" ] && [ -f "${{ steps.attest_provenance.outputs.bundle-path }}" ]; then
            # Debug: Show bundle structure and content
            echo "Bundle structure keys:"
            jq -r 'keys' "${{ steps.attest_provenance.outputs.bundle-path }}" || echo "Failed to get keys"
            echo "Full bundle content (first 10 lines):"
            head -10 "${{ steps.attest_provenance.outputs.bundle-path }}" || echo "Failed to read bundle"
            
            # Try multiple paths to extract logIndex with improved logic
            LOG_INDEX=""
            
            # Path 1: Standard Sigstore bundle format
            LOG_INDEX=$(jq -r '.verificationMaterial.tlogEntries[0].logIndex // empty' "${{ steps.attest_provenance.outputs.bundle-path }}" 2>/dev/null)
            if [ -n "$LOG_INDEX" ] && [ "$LOG_INDEX" != "null" ]; then
              echo "Found logIndex via path 1 (verificationMaterial.tlogEntries): $LOG_INDEX"
            else
              # Path 2: Alternative bundle format
              LOG_INDEX=$(jq -r '.tlogEntries[0].logIndex // empty' "${{ steps.attest_provenance.outputs.bundle-path }}" 2>/dev/null)
              if [ -n "$LOG_INDEX" ] && [ "$LOG_INDEX" != "null" ]; then
                echo "Found logIndex via path 2 (tlogEntries): $LOG_INDEX"
              else
                # Path 3: Nested in x509 certificate chain
                LOG_INDEX=$(jq -r '.verificationMaterial.x509CertificateChain.certificates[0].logIndex // empty' "${{ steps.attest_provenance.outputs.bundle-path }}" 2>/dev/null)
                if [ -n "$LOG_INDEX" ] && [ "$LOG_INDEX" != "null" ]; then
                  echo "Found logIndex via path 3 (x509CertificateChain): $LOG_INDEX"
                else
                  # Path 4: Check if it's wrapped in a different structure
                  LOG_INDEX=$(jq -r '.bundle.verificationMaterial.tlogEntries[0].logIndex // .envelope.verificationMaterial.tlogEntries[0].logIndex // empty' "${{ steps.attest_provenance.outputs.bundle-path }}" 2>/dev/null)
                  if [ -n "$LOG_INDEX" ] && [ "$LOG_INDEX" != "null" ]; then
                    echo "Found logIndex via path 4 (nested bundle/envelope): $LOG_INDEX"
                  fi
                fi
              fi
            fi
            
            if [ -n "$LOG_INDEX" ] && [ "$LOG_INDEX" != "null" ]; then
              echo "logindex=$LOG_INDEX" >> $GITHUB_OUTPUT
              echo "sigstore_url=https://search.sigstore.dev/?logIndex=$LOG_INDEX" >> $GITHUB_OUTPUT
              echo "Found Sigstore logIndex: $LOG_INDEX"
              echo "Sigstore URL: https://search.sigstore.dev/?logIndex=$LOG_INDEX"
              
              # Save to file for release page generation
              echo "GITHUB_ATTESTATION_URL=${{ steps.attest_provenance.outputs.attestation-url }}" > "$output_file"
              echo "SIGSTORE_URL=https://search.sigstore.dev/?logIndex=$LOG_INDEX" >> "$output_file"
              echo "LOG_INDEX=$LOG_INDEX" >> "$output_file"
            else
              echo "No logIndex found in attestation bundle via standard paths"
              
              # Enhanced fallback: Try to extract from attestation URL and alternative bundle parsing
              ATTESTATION_URL="${{ steps.attest_provenance.outputs.attestation-url }}"
              
              # Fallback 1: Extract logIndex from attestation URL if available
              URL_LOG_INDEX=""
              if [ -n "$ATTESTATION_URL" ]; then
                echo "Trying to extract logIndex from attestation URL: $ATTESTATION_URL"
                URL_LOG_INDEX=$(echo "$ATTESTATION_URL" | grep -o 'logIndex=[0-9]\+' | cut -d'=' -f2 || echo "")
                if [ -n "$URL_LOG_INDEX" ]; then
                  echo "Found logIndex in URL: $URL_LOG_INDEX"
                  LOG_INDEX="$URL_LOG_INDEX"
                fi
              fi
              
              # Fallback 2: Try cosign-style bundle parsing if available
              if [ -z "$LOG_INDEX" ] && [ -f "${{ steps.attest_provenance.outputs.bundle-path }}" ]; then
                echo "Attempting alternative bundle parsing with cosign-style paths"
                # Try to find any numeric logIndex value in the bundle
                LOG_INDEX=$(jq -r '.. | objects | select(has("logIndex")) | .logIndex' "${{ steps.attest_provenance.outputs.bundle-path }}" 2>/dev/null | head -1)
                if [ -n "$LOG_INDEX" ] && [ "$LOG_INDEX" != "null" ]; then
                  echo "Found logIndex via recursive search: $LOG_INDEX"
                else
                  # Try looking for logId which might be the same
                  LOG_INDEX=$(jq -r '.. | objects | select(has("logId")) | .logId' "${{ steps.attest_provenance.outputs.bundle-path }}" 2>/dev/null | head -1)
                  if [ -n "$LOG_INDEX" ] && [ "$LOG_INDEX" != "null" ]; then
                    echo "Found logId (treating as logIndex): $LOG_INDEX"
                  fi
                fi
              fi
              
              # Set outputs based on what we found
              if [ -n "$LOG_INDEX" ] && [ "$LOG_INDEX" != "null" ]; then
                echo "logindex=$LOG_INDEX" >> $GITHUB_OUTPUT
                echo "sigstore_url=https://search.sigstore.dev/?logIndex=$LOG_INDEX" >> $GITHUB_OUTPUT
                echo "Successfully recovered logIndex: $LOG_INDEX"
                
                # Save to file for release page generation
                echo "GITHUB_ATTESTATION_URL=$ATTESTATION_URL" > "$output_file"
                echo "SIGSTORE_URL=https://search.sigstore.dev/?logIndex=$LOG_INDEX" >> "$output_file"
                echo "LOG_INDEX=$LOG_INDEX" >> "$output_file"
              else
                echo "Unable to extract logIndex from any source"
                echo "logindex=" >> $GITHUB_OUTPUT
                echo "sigstore_url=" >> $GITHUB_OUTPUT
                
                # Save GitHub attestation URL only
                if [ -n "$ATTESTATION_URL" ]; then
                  echo "GITHUB_ATTESTATION_URL=$ATTESTATION_URL" > "$output_file"
                else
                  echo "GITHUB_ATTESTATION_URL=" > "$output_file"
                fi
                echo "SIGSTORE_URL=" >> "$output_file"
                echo "LOG_INDEX=" >> "$output_file"
              fi
            fi
          else
            echo "logindex=" >> $GITHUB_OUTPUT
            echo "sigstore_url=" >> $GITHUB_OUTPUT
            echo "Attestation bundle file not found"
            
            # Create empty file
            echo "GITHUB_ATTESTATION_URL=" > "$output_file"
            echo "SIGSTORE_URL=" >> "$output_file"
            echo "LOG_INDEX=" >> "$output_file"
          fi
          
          echo "provenance_file_path=$output_file" >> $GITHUB_OUTPUT

      - name: Upload provenance artifact for ${{ matrix.platform }}
        uses: actions/upload-artifact@v4
        if: github.event_name == 'push' && github.ref_type == 'tag' && steps.extract_logindex.outputs.provenance_file_path != ''
        with:
          name: provenance-${{ steps.context.outputs.image-base-name }}-${{ steps.context.outputs.platform-suffix }}
          path: ${{ steps.extract_logindex.outputs.provenance_file_path }}
          retention-days: 1
          if-no-files-found: warn

      - name: Output SHA256 digest for ${{ matrix.platform }}
        if: github.event_name == 'push' && github.ref_type == 'tag'
        run: |
          echo "SHA256 digest for ${{ steps.context.outputs.image-name }}: ${{ steps.docker_build.outputs.digest }}"

      - name: Determine Repository Owner Type for ${{ matrix.platform }}
        id: owner_type
        if: github.event_name == 'push' && github.ref_type == 'tag' && steps.docker_build.outputs.digest != ''
        env:
          OWNER_LOGIN: ${{ github.repository_owner }} 
          # GH_TOKEN is inherited from the job-level env
        run: |
          echo "Determining owner type for $OWNER_LOGIN"
          OWNER_TYPE_JSON=$(gh api "users/$OWNER_LOGIN" --jq '.type')
          # Remove quotes from JSON string output by jq
          OWNER_TYPE=$(echo "$OWNER_TYPE_JSON" | tr -d '"')

          echo "Raw type from API: '$OWNER_TYPE_JSON', Parsed type: '$OWNER_TYPE'"

          if [ "$OWNER_TYPE" = "User" ]; then
            echo "api_path_segment=users" >> $GITHUB_OUTPUT
            echo "Determined owner type for $OWNER_LOGIN: User"
          elif [ "$OWNER_TYPE" = "Organization" ]; then
            echo "api_path_segment=orgs" >> $GITHUB_OUTPUT
            echo "Determined owner type for $OWNER_LOGIN: Organization"
          else
            echo "::error::Could not determine owner type for '$OWNER_LOGIN'. Received type: '$OWNER_TYPE'."
            echo "Full API response for users/$OWNER_LOGIN:"
            gh api "users/$OWNER_LOGIN"
            exit 1
          fi

      - name: Make Package Public on GHCR for ${{ matrix.platform }}
        if: steps.docker_build.outputs.digest != '' && steps.owner_type.outputs.api_path_segment != '' && github.event_name == 'push' && github.ref_type == 'tag'
        continue-on-error: true
        env:
          PACKAGE_NAME: ${{ github.event.repository.name }}/${{ steps.context.outputs.image-name }}
          OWNER: ${{ github.repository_owner }}
          API_PATH_SEGMENT: ${{ steps.owner_type.outputs.api_path_segment }}
          # GH_TOKEN is now inherited from the job-level env
        run: |
          # URL encode the package name (replace / with %2F)
          ENCODED_PACKAGE_NAME=$(echo "$PACKAGE_NAME" | sed 's|/|%2F|g')
          API_URL_PATH="/${API_PATH_SEGMENT}/${OWNER}/packages/container/${ENCODED_PACKAGE_NAME}"
          echo "Package name: $PACKAGE_NAME"
          echo "Encoded package name: $ENCODED_PACKAGE_NAME"
          echo "Target API path: $API_URL_PATH"

          # Wait for package to be available in GHCR API
          echo "Waiting 10 seconds for package to be available in GHCR API..."
          sleep 10

          max_attempts=5
          attempt_num=1
          success=false
          while [ $attempt_num -le $max_attempts ]; do
            echo "Attempt $attempt_num of $max_attempts to set package visibility for '$PACKAGE_NAME'..."
            if gh api \
              --method PATCH \
              -H "Accept: application/vnd.github.package-deletes-preview+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "$API_URL_PATH" \
              -f visibility='public' \
              --silent; then
              echo "Successfully set package '$PACKAGE_NAME' to public."
              success=true
              break
            else
              ERROR_CODE=$?
              echo "Attempt $attempt_num failed with exit code $ERROR_CODE."
              # Check if it's already public, which is a success condition.
              CURRENT_VISIBILITY=$(gh api "$API_URL_PATH" --jq .visibility --silent 2>/dev/null | tr -d '"')
              if [ "$CURRENT_VISIBILITY" = "public" ]; then
                echo "Package '$PACKAGE_NAME' is already public. Considering this a success."
                success=true
                break
              fi

              if [ $attempt_num -eq $max_attempts ]; then
                break # Exit loop on final attempt
              fi

              echo "Waiting 5 seconds before retrying..."
              sleep 5
              ((attempt_num++))
            fi
          done

          if [ "$success" = "false" ]; then
            echo "::warning::Failed to set package '$PACKAGE_NAME' to public after $max_attempts attempts."
            echo "Full package details for diagnostics:"
            gh api "$API_URL_PATH" --silent || echo "::warning::Fetching package details also failed, which may happen if the package was never created."
            echo "::warning::Package visibility could not be set to public, but build will continue."
          fi

  create_release:
    runs-on: ubuntu-latest
    needs: publish_image
    if: github.event_name == 'push' && github.ref_type == 'tag' && needs.publish_image.result == 'success'
    permissions:
      contents: write
      actions: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Parse tag for release info
        id: parse_tag_release
        uses: ./.github/actions/parse-image-context
        with:
          tag: ${{ github.ref }}
          platform: linux/amd64  # Platform doesn't matter for release parsing

      - name: Download AMD64 versions artifact
        id: download_artifact_amd64
        if: |
          steps.parse_tag_release.outputs.image-base-name == 'python-base' ||
          steps.parse_tag_release.outputs.image-base-name == 'nodejs-base' ||
          steps.parse_tag_release.outputs.image-base-name == 'openjdk17-base' ||
          steps.parse_tag_release.outputs.image-base-name == 'go-base'
        continue-on-error: true
        uses: actions/download-artifact@v5
        with:
          name: versions-file-linux-amd64
          path: .

      - name: Download ARM64 versions artifact
        id: download_artifact_arm64
        if: |
          steps.parse_tag_release.outputs.image-base-name == 'python-base' ||
          steps.parse_tag_release.outputs.image-base-name == 'nodejs-base' ||
          steps.parse_tag_release.outputs.image-base-name == 'openjdk17-base' ||
          steps.parse_tag_release.outputs.image-base-name == 'go-base'
        continue-on-error: true
        uses: actions/download-artifact@v5
        with:
          name: versions-file-linux-arm64
          path: .

      - name: Download AMD64 provenance artifact
        id: download_provenance_amd64
        continue-on-error: true
        uses: actions/download-artifact@v5
        with:
          name: provenance-${{ steps.parse_tag_release.outputs.image-base-name }}-linux-amd64
          path: .

      - name: Download ARM64 provenance artifact
        id: download_provenance_arm64
        continue-on-error: true
        uses: actions/download-artifact@v5
        with:
          name: provenance-${{ steps.parse_tag_release.outputs.image-base-name }}-linux-arm64
          path: .

      - name: Create GitHub Release Body
        id: release_body
        run: |
          image_base_name="${{ steps.parse_tag_release.outputs.image-base-name }}"
          version_tag="${{ steps.parse_tag_release.outputs.version }}"
          repo_name="${{ github.repository }}"
          registry="${{ env.REGISTRY }}"

          # Function to extract value from a versions file
          get_version_value() {
            local file="$1"
            local key="$2"
            if [ -f "$file" ]; then
              grep "^${key}=" "$file" | cut -d'=' -f2
            fi
          }

          # Initialize version variables
          py_major_amd64="" py_minor_amd64="" py_full_amd64=""
          py_major_arm64="" py_minor_arm64="" py_full_arm64=""
          node_major_amd64="" node_minor_amd64="" node_full_amd64=""
          node_major_arm64="" node_minor_arm64="" node_full_arm64=""
          jdk_major_amd64="" jdk_minor_amd64="" jdk_full_amd64=""
          jdk_major_arm64="" jdk_minor_arm64="" jdk_full_arm64=""
          go_major_amd64="" go_minor_amd64="" go_full_amd64=""
          go_major_arm64="" go_minor_arm64="" go_full_arm64=""

          # Read versions if files exist
          if [[ "${{ steps.download_artifact_amd64.outcome }}" == "success" ]]; then
              echo "Reading AMD64 versions file..."
              py_major_amd64=$(get_version_value "env.versions.linux-amd64" "python_major_tag")
              py_minor_amd64=$(get_version_value "env.versions.linux-amd64" "python_minor_tag")
              py_full_amd64=$(get_version_value "env.versions.linux-amd64" "python")
              node_major_amd64=$(get_version_value "env.versions.linux-amd64" "nodejs_major_tag")
              node_minor_amd64=$(get_version_value "env.versions.linux-amd64" "nodejs_minor_tag")
              node_full_amd64=$(get_version_value "env.versions.linux-amd64" "nodejs")
              jdk_major_amd64=$(get_version_value "env.versions.linux-amd64" "java_major_tag")
              jdk_minor_amd64=$(get_version_value "env.versions.linux-amd64" "java_minor_tag")
              jdk_full_amd64=$(get_version_value "env.versions.linux-amd64" "java")
              go_major_amd64=$(get_version_value "env.versions.linux-amd64" "go_major_tag")
              go_minor_amd64=$(get_version_value "env.versions.linux-amd64" "go_minor_tag")
              go_full_amd64=$(get_version_value "env.versions.linux-amd64" "go")
          else
              echo "AMD64 versions artifact not downloaded or download failed."
          fi

          if [[ "${{ steps.download_artifact_arm64.outcome }}" == "success" ]]; then
              echo "Reading ARM64 versions file..."
              py_major_arm64=$(get_version_value "env.versions.linux-arm64" "python_major_tag")
              py_minor_arm64=$(get_version_value "env.versions.linux-arm64" "python_minor_tag")
              py_full_arm64=$(get_version_value "env.versions.linux-arm64" "python")
              node_major_arm64=$(get_version_value "env.versions.linux-arm64" "nodejs_major_tag")
              node_minor_arm64=$(get_version_value "env.versions.linux-arm64" "nodejs_minor_tag")
              node_full_arm64=$(get_version_value "env.versions.linux-arm64" "nodejs")
              jdk_major_arm64=$(get_version_value "env.versions.linux-arm64" "java_major_tag")
              jdk_minor_arm64=$(get_version_value "env.versions.linux-arm64" "java_minor_tag")
              jdk_full_arm64=$(get_version_value "env.versions.linux-arm64" "java")
              go_major_arm64=$(get_version_value "env.versions.linux-arm64" "go_major_tag")
              go_minor_arm64=$(get_version_value "env.versions.linux-arm64" "go_minor_tag")
              go_full_arm64=$(get_version_value "env.versions.linux-arm64" "go")
          else
              echo "ARM64 versions artifact not downloaded or download failed."
          fi

          # Read provenance information if files exist
          sigstore_amd64="" github_attestation_amd64=""
          sigstore_arm64="" github_attestation_arm64=""
          
          if [[ "${{ steps.download_provenance_amd64.outcome }}" == "success" ]]; then
              echo "Reading AMD64 provenance file..."
              sigstore_amd64=$(get_version_value "env.provenance.linux-amd64" "SIGSTORE_URL")
              github_attestation_amd64=$(get_version_value "env.provenance.linux-amd64" "GITHUB_ATTESTATION_URL")
          else
              echo "AMD64 provenance artifact not downloaded or download failed."
          fi
          
          if [[ "${{ steps.download_provenance_arm64.outcome }}" == "success" ]]; then
              echo "Reading ARM64 provenance file..."
              sigstore_arm64=$(get_version_value "env.provenance.linux-arm64" "SIGSTORE_URL")
              github_attestation_arm64=$(get_version_value "env.provenance.linux-arm64" "GITHUB_ATTESTATION_URL")
          else
              echo "ARM64 provenance artifact not downloaded or download failed."
          fi

          # Consolidate version info using generic variables
          LANGUAGE_NAME=""
          MAJOR_AMD64="" MINOR_AMD64="" FULL_AMD64=""
          MAJOR_ARM64="" MINOR_ARM64="" FULL_ARM64=""

          case "$image_base_name" in
            "python-base")
              LANGUAGE_NAME="Python"
              MAJOR_AMD64=$py_major_amd64; MINOR_AMD64=$py_minor_amd64; FULL_AMD64=$py_full_amd64
              MAJOR_ARM64=$py_major_arm64; MINOR_ARM64=$py_minor_arm64; FULL_ARM64=$py_full_arm64
              ;;
            "nodejs-base")
              LANGUAGE_NAME="Node.js"
              MAJOR_AMD64=$node_major_amd64; MINOR_AMD64=$node_minor_amd64; FULL_AMD64=$node_full_amd64
              MAJOR_ARM64=$node_major_arm64; MINOR_ARM64=$node_minor_arm64; FULL_ARM64=$node_full_arm64
              ;;
            "openjdk17-base")
              LANGUAGE_NAME="OpenJDK"
              MAJOR_AMD64=$jdk_major_amd64; MINOR_AMD64=$jdk_minor_amd64; FULL_AMD64=$jdk_full_amd64
              MAJOR_ARM64=$jdk_major_arm64; MINOR_ARM64=$jdk_minor_arm64; FULL_ARM64=$jdk_full_arm64
              ;;
            "go-base")
              LANGUAGE_NAME="Go"
              MAJOR_AMD64=$go_major_amd64; MINOR_AMD64=$go_minor_amd64; FULL_AMD64=$go_full_amd64
              MAJOR_ARM64=$go_major_arm64; MINOR_ARM64=$go_minor_arm64; FULL_ARM64=$go_full_arm64
              ;;
          esac

          # Build Release Body
          if [ -n "$LANGUAGE_NAME" ]; then
            # Language-specific images
            intro_text="Platform-specific Docker images for \`$image_base_name\` version \`$version_tag\` pushed.

          **For CI/CD stability, we strongly recommend pinning to major.minor versions (e.g., \`${MINOR_AMD64:-X.Y}\`) rather than \`latest\` or specific semver tags.** This provides the best balance of security updates while avoiding breaking changes."
          else
            # Non-language base images  
            intro_text="Platform-specific Docker images for \`$image_base_name\` version \`$version_tag\` pushed.

          **For non-language base images, pin to \`:latest\` tag with \`docker pull\` in your CI** to ensure you get the latest security updates and base image improvements."
          fi

          body=$(cat <<EOF
          $intro_text

          **Published Images & Tags:**

          *   **linux/amd64:**
              *   Image: \`$registry/$repo_name/$image_base_name-linux-amd64\`
              *   Tag: \`$version_tag\`
              *   Tag: \`latest\`
              $( [ -n "$MAJOR_AMD64" ] && printf "*   Tag: \`%s\`\n" "$MAJOR_AMD64" || true ) \
              $( [ -n "$MINOR_AMD64" ] && printf "*   Tag: \`%s\`\n" "$MINOR_AMD64" || true )
          *   **linux/arm64:**
              *   Image: \`$registry/$repo_name/$image_base_name-linux-arm64\`
              *   Tag: \`$version_tag\`
              *   Tag: \`latest\`
              $( [ -n "$MAJOR_ARM64" ] && printf "*   Tag: \`%s\`\n" "$MAJOR_ARM64" || true ) \
              $( [ -n "$MINOR_ARM64" ] && printf "*   Tag: \`%s\`\n" "$MINOR_ARM64" || true )
          EOF
          )

          # Add content specific to image type
          if [ -n "$LANGUAGE_NAME" ]; then
            # Language-specific images: version details + best practices + examples
            version_details="

          **$LANGUAGE_NAME Version Details:**
          *   AMD64: Major=\`${MAJOR_AMD64:-N/A}\`, Minor=\`${MINOR_AMD64:-N/A}\`, Full=\`${FULL_AMD64:-N/A}\`
          *   ARM64: Major=\`${MAJOR_ARM64:-N/A}\`, Minor=\`${MINOR_ARM64:-N/A}\`, Full=\`${FULL_ARM64:-N/A}\`

          **🎯 $LANGUAGE_NAME Runtime Pinning Best Practices:**
          * **✅ Recommended for CI/CD**: Pin to major.minor (e.g., \`${MINOR_AMD64:-X.Y}\`) - Gets security patches, avoids breaking changes
          * **⚠️ Use with caution**: \`:latest\` tag - May introduce breaking changes unexpectedly  
          * **⚠️ Avoid in CI**: Specific semver tags (e.g., \`$version_tag\`) - Misses important security updates
          * **⚠️ High risk**: Major-only tags (e.g., \`${MAJOR_AMD64:-X}\`) - May include breaking changes within major versions

          **Dockerfile Examples:**

          **For Production/CI (Recommended):**
          * **AMD64**: \`FROM $registry/$repo_name/${image_base_name}-linux-amd64:${MINOR_AMD64:-latest}\`
          * **ARM64**: \`FROM $registry/$repo_name/${image_base_name}-linux-arm64:${MINOR_ARM64:-latest}\`
          * **Build command**: \`docker build --pull ...\`

          **Pull Examples:**

          **For Production/CI (Recommended):**"
            body+="$version_details"

            # Add recommended major.minor examples
            if [ -n "$MINOR_AMD64" ]; then
              body+=$(printf '\n* **AMD64 (Recommended)**: \`docker pull %s/%s/%s-linux-amd64:%s\`' "$registry" "$repo_name" "$image_base_name" "$MINOR_AMD64")
            fi
            if [ -n "$MINOR_ARM64" ]; then
              body+=$(printf '\n* **ARM64 (Recommended)**: \`docker pull %s/%s/%s-linux-arm64:%s\`' "$registry" "$repo_name" "$image_base_name" "$MINOR_ARM64")
            fi

            body+=$'\n\n**For Development/Testing:**'
            body+=$(printf '\n* **AMD64 (Latest)**: \`docker pull %s/%s/%s-linux-amd64:latest\`' "$registry" "$repo_name" "$image_base_name")
            body+=$(printf '\n* **ARM64 (Latest)**: \`docker pull %s/%s/%s-linux-arm64:latest\`' "$registry" "$repo_name" "$image_base_name")
            body+=$'\n\n**🔐 Build Provenance & Supply Chain Security:**'

            if [ -n "$sigstore_amd64" ] || [ -n "$sigstore_arm64" ]; then
              body+=$'\n\n**Sigstore Transparency Log:**'
              if [ -n "$sigstore_amd64" ]; then
                body+=$(printf '\n* **AMD64**: [%s](%s)' "View in Sigstore" "$sigstore_amd64")
              fi
              if [ -n "$sigstore_arm64" ]; then
                body+=$(printf '\n* **ARM64**: [%s](%s)' "View in Sigstore" "$sigstore_arm64")
              fi
            fi
            if [ -n "$github_attestation_amd64" ] || [ -n "$github_attestation_arm64" ]; then
              body+=$'\n\n**GitHub Attestations:**'
              if [ -n "$github_attestation_amd64" ]; then
                body+=$(printf '\n* **AMD64**: [%s](%s)' "View Attestation" "$github_attestation_amd64")
              fi
              if [ -n "$github_attestation_arm64" ]; then
                body+=$(printf '\n* **ARM64**: [%s](%s)' "View Attestation" "$github_attestation_arm64")
              fi
            fi
            body+=$'\n\n**🔐 Public Verification (No authentication required):**'
            body+=$'\n```bash'
            body+=$'\n# Install cosign: https://docs.sigstore.dev/cosign/installation'
            body+=$(printf '\ncosign verify \\\n  --certificate-identity-regexp "https://github.com/%s/.github/workflows/.*" \\\n  --certificate-oidc-issuer "https://token.actions.githubusercontent.com" \\\n  %s/%s/%s-linux-amd64:%s | jq' "$repo_name" "$registry" "$repo_name" "$image_base_name" "${MINOR_AMD64:-latest}")
            body+=$'\n'
            body+=$(printf '\ncosign verify \\\n  --certificate-identity-regexp "https://github.com/%s/.github/workflows/.*" \\\n  --certificate-oidc-issuer "https://token.actions.githubusercontent.com" \\\n  %s/%s/%s-linux-arm64:%s | jq' "$repo_name" "$registry" "$repo_name" "$image_base_name" "${MINOR_ARM64:-latest}")
            body+=$'\n```'
          else
            # Non-language base images: best practices + examples
            base_practices="

          **🎯 Non-language Base Image Best Practices:**
          * **✅ Recommended for CI/CD**: Use \`:latest\` with \`docker build --pull ...\` - Ensures latest security patches
          * **💡 Why use :latest tag?** Non-language base images are unlikely to introduce build issues when their version changes and it ensures you receive the latest security patches.
         

          **Dockerfile Examples:**

          **For Production/CI (Recommended):**
          * **AMD64**: \`FROM $registry/$repo_name/${image_base_name}-linux-amd64:latest\`
          * **ARM64**: \`FROM $registry/$repo_name/${image_base_name}-linux-arm64:latest\`
          * **Build command**: \`docker build --pull ...\`

          **🔐 Build Provenance & Supply Chain Security:**"
          
          if [ -n "$sigstore_amd64" ] || [ -n "$sigstore_arm64" ]; then
            base_practices+=$'\n\n**Sigstore Transparency Log:**'
            if [ -n "$sigstore_amd64" ]; then
              base_practices+=$(printf '\n* **AMD64**: [%s](%s)' "View in Sigstore" "$sigstore_amd64")
            fi
            if [ -n "$sigstore_arm64" ]; then
              base_practices+=$(printf '\n* **ARM64**: [%s](%s)' "View in Sigstore" "$sigstore_arm64")
            fi
          fi
          
          if [ -n "$github_attestation_amd64" ] || [ -n "$github_attestation_arm64" ]; then
            base_practices+=$'\n\n**GitHub Attestations:**'
            if [ -n "$github_attestation_amd64" ]; then
              base_practices+=$(printf '\n* **AMD64**: [%s](%s)' "View Attestation" "$github_attestation_amd64")
            fi
            if [ -n "$github_attestation_arm64" ]; then
              base_practices+=$(printf '\n* **ARM64**: [%s](%s)' "View Attestation" "$github_attestation_arm64")
            fi
          fi
          
          base_practices+=$'\n\n**🔐 Public Verification (No authentication required):**'
          base_practices+=$'\n```bash'
          base_practices+=$'\n# Install cosign: https://docs.sigstore.dev/cosign/installation'
          base_practices+=$(printf '\ncosign verify \\\n  --certificate-identity-regexp "https://github.com/%s/.github/workflows/.*" \\\n  --certificate-oidc-issuer "https://token.actions.githubusercontent.com" \\\n  %s/%s/%s-linux-amd64:latest | jq' "$repo_name" "$registry" "$repo_name" "$image_base_name")
          base_practices+=$'\n'
          base_practices+=$(printf '\ncosign verify \\\n  --certificate-identity-regexp "https://github.com/%s/.github/workflows/.*" \\\n  --certificate-oidc-issuer "https://token.actions.githubusercontent.com" \\\n  %s/%s/%s-linux-arm64:latest | jq' "$repo_name" "$registry" "$repo_name" "$image_base_name")
          base_practices+=$'\n```'
            body+="$base_practices"
          fi

          echo "Setting BODY_TEXT environment variable..."
          echo "BODY_TEXT<<EOF" >> $GITHUB_ENV
          echo "$body" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: "Release ${{ steps.parse_tag_release.outputs.image-base-name }} ${{ steps.parse_tag_release.outputs.version }}"
          body: ${{ env.BODY_TEXT }}
          draft: false
          prerelease: ${{ contains(steps.parse_tag_release.outputs.version, '-') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  create_multiarch_manifests:
    needs: [publish_image, create_release]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref_type == 'tag' && needs.publish_image.result == 'success' && needs.create_release.result == 'success'
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Parse tag information
        id: parse_tag
        run: |
          tag="${{ github.ref_name }}"
          if [[ $tag =~ ^release/([^/]+)/(v.+)$ ]]; then
            image_base_name="${BASH_REMATCH[1]}"
            version="${BASH_REMATCH[2]}"
            echo "image_base_name=$image_base_name" >> $GITHUB_OUTPUT
            echo "version=$version" >> $GITHUB_OUTPUT
            echo "Parsed: image=$image_base_name, version=$version"
          else
            echo "Invalid tag format: $tag"
            exit 1
          fi

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract version tags from artifacts
        id: version_info
        run: |
          # Download version artifacts if they exist
          image_name="${{ steps.parse_tag.outputs.image_base_name }}"
          
          # Try to download version artifacts from both platforms
          mkdir -p version_artifacts
          
          # Check if artifacts exist and download them
          for platform in linux-amd64 linux-arm64; do
            artifact_name="version-tags-$image_name-$platform"
            echo "Checking for artifact: $artifact_name"
            
            # Download artifact if it exists (will fail silently if not found)
            if gh run download ${{ github.run_id }} -n "$artifact_name" -D "version_artifacts/" 2>/dev/null || true; then
              echo "Downloaded version artifact for $platform"
              if [ -f "version_artifacts/version_tags.env" ]; then
                source "version_artifacts/version_tags.env"
                echo "major_tag=$major_tag" >> $GITHUB_OUTPUT
                echo "minor_tag=$minor_tag" >> $GITHUB_OUTPUT
                echo "has_version_tags=true" >> $GITHUB_OUTPUT
                echo "Found version tags: major=$major_tag, minor=$minor_tag"
                break
              fi
            fi
          done
          
          # If no version tags found, mark as false
          if [ ! -f "version_artifacts/version_tags.env" ]; then
            echo "has_version_tags=false" >> $GITHUB_OUTPUT
            echo "No version tags found"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create multi-arch manifests
        run: |
          image_base_name="${{ steps.parse_tag.outputs.image_base_name }}"
          version="${{ steps.parse_tag.outputs.version }}"
          registry="${{ env.REGISTRY }}/${{ github.repository }}"
          
          echo "Creating multi-arch manifests for $image_base_name"
          
          # Base images for manifest creation
          amd64_image="$registry/$image_base_name-linux-amd64"
          arm64_image="$registry/$image_base_name-linux-arm64"
          universal_image="$registry/$image_base_name"
          
          echo "Checking if source images exist:"
          echo "AMD64: $amd64_image:$version"
          docker manifest inspect "$amd64_image:$version" >/dev/null && echo "✅ AMD64 image exists" || echo "❌ AMD64 image missing"
          echo "ARM64: $arm64_image:$version"
          docker manifest inspect "$arm64_image:$version" >/dev/null && echo "✅ ARM64 image exists" || echo "❌ ARM64 image missing"
          
          echo "AMD64: $amd64_image:latest"
          docker manifest inspect "$amd64_image:latest" >/dev/null && echo "✅ AMD64 latest exists" || echo "❌ AMD64 latest missing"
          echo "ARM64: $arm64_image:latest"
          docker manifest inspect "$arm64_image:latest" >/dev/null && echo "✅ ARM64 latest exists" || echo "❌ ARM64 latest missing"
          
          # Get digests for specific platforms
          echo "Getting platform-specific digests..."
          amd64_digest=$(docker manifest inspect "$amd64_image:$version" | jq -r '.manifests[] | select(.platform.architecture=="amd64") | .digest')
          arm64_digest=$(docker manifest inspect "$arm64_image:$version" | jq -r '.manifests[] | select(.platform.architecture=="arm64") | .digest')
          
          amd64_latest_digest=$(docker manifest inspect "$amd64_image:latest" | jq -r '.manifests[] | select(.platform.architecture=="amd64") | .digest')
          arm64_latest_digest=$(docker manifest inspect "$arm64_image:latest" | jq -r '.manifests[] | select(.platform.architecture=="arm64") | .digest')
          
          echo "AMD64 version digest: $amd64_digest"
          echo "ARM64 version digest: $arm64_digest"
          echo "AMD64 latest digest: $amd64_latest_digest"
          echo "ARM64 latest digest: $arm64_latest_digest"
          
          # Create unified manifest for semver version using digests
          echo "Creating manifest for $universal_image:$version"
          docker manifest create "$universal_image:$version" \
            "$amd64_image@$amd64_digest" \
            "$arm64_image@$arm64_digest" || \
          docker manifest create --amend "$universal_image:$version" \
            "$amd64_image@$amd64_digest" \
            "$arm64_image@$arm64_digest"
          docker manifest push "$universal_image:$version"
          
          # Create unified manifest for latest using digests
          echo "Creating manifest for $universal_image:latest"
          docker manifest create "$universal_image:latest" \
            "$amd64_image@$amd64_latest_digest" \
            "$arm64_image@$arm64_latest_digest" || \
          docker manifest create --amend "$universal_image:latest" \
            "$amd64_image@$amd64_latest_digest" \
            "$arm64_image@$arm64_latest_digest"
          docker manifest push "$universal_image:latest"
          
          # Create version-specific manifests if available
          if [[ "${{ steps.version_info.outputs.has_version_tags }}" == "true" ]]; then
            major_tag="${{ steps.version_info.outputs.major_tag }}"
            minor_tag="${{ steps.version_info.outputs.minor_tag }}"
            
            if [[ -n "$major_tag" ]]; then
              echo "Creating manifest for $universal_image:$major_tag"
              # Get digests for major tag
              major_amd64_digest=$(docker manifest inspect "$amd64_image:$major_tag" | jq -r '.manifests[] | select(.platform.architecture=="amd64") | .digest')
              major_arm64_digest=$(docker manifest inspect "$arm64_image:$major_tag" | jq -r '.manifests[] | select(.platform.architecture=="arm64") | .digest')
              
              docker manifest create "$universal_image:$major_tag" \
                "$amd64_image@$major_amd64_digest" \
                "$arm64_image@$major_arm64_digest" || \
              docker manifest create --amend "$universal_image:$major_tag" \
                "$amd64_image@$major_amd64_digest" \
                "$arm64_image@$major_arm64_digest"
              docker manifest push "$universal_image:$major_tag"
            fi
            
            if [[ -n "$minor_tag" ]]; then
              echo "Creating manifest for $universal_image:$minor_tag"
              # Get digests for minor tag  
              minor_amd64_digest=$(docker manifest inspect "$amd64_image:$minor_tag" | jq -r '.manifests[] | select(.platform.architecture=="amd64") | .digest')
              minor_arm64_digest=$(docker manifest inspect "$arm64_image:$minor_tag" | jq -r '.manifests[] | select(.platform.architecture=="arm64") | .digest')
              
              docker manifest create "$universal_image:$minor_tag" \
                "$amd64_image@$minor_amd64_digest" \
                "$arm64_image@$minor_arm64_digest" || \
              docker manifest create --amend "$universal_image:$minor_tag" \
                "$amd64_image@$minor_amd64_digest" \
                "$arm64_image@$minor_arm64_digest"
              docker manifest push "$universal_image:$minor_tag"
            fi
          fi
          
          echo "✅ Multi-arch manifests created successfully"

      - name: Verify multi-arch manifests
        run: |
          image_base_name="${{ steps.parse_tag.outputs.image_base_name }}"
          version="${{ steps.parse_tag.outputs.version }}"
          registry="${{ env.REGISTRY }}/${{ github.repository }}"
          universal_image="$registry/$image_base_name"
          
          echo "Verifying multi-arch manifests:"
          
          # Verify semver and latest tags
          for tag in "$version" "latest"; do
            echo "Checking $universal_image:$tag"
            docker manifest inspect "$universal_image:$tag" | jq '.manifests[].platform'
          done
          
          # Verify version tags if they exist
          if [[ "${{ steps.version_info.outputs.has_version_tags }}" == "true" ]]; then
            major_tag="${{ steps.version_info.outputs.major_tag }}"
            minor_tag="${{ steps.version_info.outputs.minor_tag }}"
            
            for tag in "$major_tag" "$minor_tag"; do
              if [[ -n "$tag" ]]; then
                echo "Checking $universal_image:$tag"
                docker manifest inspect "$universal_image:$tag" | jq '.manifests[].platform'
              fi
            done
          fi